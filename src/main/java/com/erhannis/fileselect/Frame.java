/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.erhannis.fileselect;

import java.awt.event.KeyEvent;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JComponent;
import javax.swing.JFileChooser;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreeModel;
import javax.swing.tree.TreeNode;
import javax.swing.tree.TreeSelectionModel;

/**
 *
 * @author erhannis
 */
public class Frame extends javax.swing.JFrame {
    private DefaultMutableTreeNode root = new DefaultMutableTreeNode(new Selection<byte[], EnumYNUM>(new byte[0], "", EnumYNUM.U));
    private TreeModel treeModel = new DefaultTreeModel(root);
    
    /**
     * Creates new form Frame
     */
    public Frame() {
        initComponents();
        jTree1.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTree1 = new javax.swing.JTree();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        miLoad = new javax.swing.JMenuItem();
        miSave = new javax.swing.JMenuItem();
        miLoadState = new javax.swing.JMenuItem();
        miSaveState = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("FileSelect");

        jTree1.setModel(treeModel        );
        jTree1.setToolTipText("<html>load file list as from `find`.<br/>green nodes are included in export.<br/>space/enter to switch state.<br/>hold shift to reverse direction.</html>");
        jTree1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTree1KeyTyped(evt);
            }
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTree1KeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(jTree1);

        jMenu1.setText("File");

        miLoad.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miLoad.setText("Load list...");
        miLoad.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miLoadActionPerformed(evt);
            }
        });
        jMenu1.add(miLoad);

        miSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_DOWN_MASK));
        miSave.setText("Export list...");
        miSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miSaveActionPerformed(evt);
            }
        });
        jMenu1.add(miSave);

        miLoadState.setText("Load state...");
        miLoadState.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miLoadStateActionPerformed(evt);
            }
        });
        jMenu1.add(miLoadState);

        miSaveState.setText("Save state...");
        miSaveState.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                miSaveStateActionPerformed(evt);
            }
        });
        jMenu1.add(miSaveState);

        jMenuBar1.add(jMenu1);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 265, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTree1KeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTree1KeyTyped
        
    }//GEN-LAST:event_jTree1KeyTyped

    private void jTree1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTree1KeyPressed
        if (evt.getKeyCode() == KeyEvent.VK_ENTER || evt.getKeyCode() == KeyEvent.VK_SPACE) {
            treeItemAction(evt.isShiftDown());
        }
    }//GEN-LAST:event_jTree1KeyPressed

    private JFileChooser chooser = new JFileChooser();
    
    private static boolean isParent(String child, String parent) {
        if (!parent.endsWith(System.getProperty("file.separator"))) {
            parent += System.getProperty("file.separator");
        }
        if (!child.startsWith(parent)) {
            return false;
        }
        return true;
    }

    private static boolean startsWith(byte[] superset, byte[] prefix) {
        if (prefix.length > superset.length) {
            return false;
        }
        for (int i = 0; i < prefix.length; i++) {
            if (superset[i] != prefix[i]) {
                return false;
            }
        }
        return true;
    }

    // Hardcoded/hacky
    private static boolean startsWith(byte[] superset, byte[] prefix1, byte prefix2) {
        if (prefix1.length+1 > superset.length) {
            return false;
        }
        for (int i = 0; i < prefix1.length; i++) {
            if (superset[i] != prefix1[i]) {
                return false;
            }
        }
        if (superset[prefix1.length] != prefix2) {
            return false;
        }
        return true;
    }
    
    private static boolean endsWith(byte[] superset, byte[] suffix) {
        if (suffix.length > superset.length) {
            return false;
        }
        for (int i = 0, j = superset.length-suffix.length; i < suffix.length; i++, j++) {
            if (superset[j] != suffix[i]) {
                return false;
            }
        }
        return true;
    }
    
    private static boolean isParent(byte[] child, byte[] parent) {
        if (parent.length == 0 || parent[parent.length-1] != 0x2F) {
            if (!startsWith(child, parent, (byte)0x2F)) {
                return false;
            }
        } else {
            if (!startsWith(child, parent)) {
                return false;
            }
        }
        return true;
    }

    private static boolean isDirectParent(byte[] child, byte[] parent) {
        if (parent.length == 0 || parent[parent.length-1] != 0x2F) {
            if (!startsWith(child, parent, (byte)0x2F)) {
                return false;
            }
            for (int i = parent.length+1; i < child.length; i++) {
                if (child[i] == 0x2F) {
                    return false;
                }
            }
            return true;
        } else {
            if (!startsWith(child, parent)) {
                return false;
            }
            for (int i = parent.length; i < child.length; i++) {
                if (child[i] == 0x2F) {
                    return false;
                }
            }
            return true;
        }
    }
    
    private static String getString(Object o) {
        if (o instanceof byte[]) {
            try {
                return new String((byte[])o);
            } catch (Throwable t) {
                return "ERROR " + o;
            }
        }
        return ""+o;
    }
    
    private static class Node<T> {
        public Node<T> parent;
        public List<Node<T>> children = new ArrayList<>();
        public T value;
        
        public Node() {
        }

        public Node(Node<T> parent, T value) {
            this.parent = parent;
            this.value = value;
        }

        public Node<T> add(T val) {
            Node<T> n = new Node<T>(this, val);
            this.children.add(n);
            return n;
        }
        
        public Node<T> addNode(Node<T> child) {
            child.parent = this;
            this.children.add(child);
            return child;
        }
        
        public DefaultMutableTreeNode toTreeNode() {
            DefaultMutableTreeNode dmtn = new DefaultMutableTreeNode(new Selection<T, EnumYNUM>(this.value, getString(this.value), EnumYNUM.U));
            for (Node<T> child : this.children) {
                dmtn.add(child.toTreeNode());
            }
            return dmtn;
        }

        public DefaultMutableTreeNode toTreeNode(HashMap<Node<byte[]>, EnumYNUM> statuses) {
            DefaultMutableTreeNode dmtn = new DefaultMutableTreeNode(new Selection<T, EnumYNUM>(this.value, getString(this.value), statuses.getOrDefault(this, EnumYNUM.U)));
            for (Node<T> child : this.children) {
                dmtn.add(child.toTreeNode(statuses));
            }
            return dmtn;
        }
        
        @Override
        public String toString() {
            return "n["+value+"]";
        }
    }
    
    private static Node<byte[]> findParent(Node<byte[]> child, Node<byte[]> root) {
        if (isDirectParent(child.value, root.value)) {
            return root;
        }
        for (Node<byte[]> candidate : root.children) {
            if (isParent(child.value, candidate.value)) {
                return findParent(child, candidate);
            }
        }
        return root;
    }
    
    // This makes me a little nervous, but I THINK it's still correct
    private Node<byte[]> cachedParent;
    private Node<byte[]> findParentCached(Node<byte[]> child, Node<byte[]> root) {
        if (cachedParent != null && isParent(child.value, cachedParent.value)) {
            cachedParent = findParent(child, cachedParent);
        } else {
            cachedParent = findParent(child, root);
        }
        return cachedParent;
    }
    
    private static <T> Iterable<T> iter(Enumeration e) {
        ArrayList<T> results = new ArrayList<T>();
        while (e.hasMoreElements()) {
            results.add((T)e.nextElement());
        }
        return results;
    }

    /**
     * Reads binary bytes into chunks separated by 0x0A.
     */
    private static class LineReader {
        private boolean runOut = false;
        private BufferedInputStream bis;
        
        public LineReader(File f) throws FileNotFoundException, IOException {
            bis = new BufferedInputStream(new FileInputStream(f));
        }
        
        public boolean hasLine() {
            return !runOut;
        }
        
        public byte[] getLine() throws IOException {
            if (runOut) {
                return null;
            }
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int b = 0;
            while ((b = bis.read()) > 0 && b != 0x0A) {
                baos.write(b);
            }
            if (b == -1) {
                runOut = true;
                bis.close();
                bis = null;
            }
            return baos.toByteArray();
        }
    }
    
    private void miLoadActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miLoadActionPerformed
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                File f = chooser.getSelectedFile();
                //List<String> lines = Files.readAllLines(f.toPath(), Charset.forName("windows-1252"));
                LineReader lr = new LineReader(f);
                Node<byte[]> r = new Node<>(null, new byte[]{});
                int i = 0;
                int j = 0;
                long time = System.currentTimeMillis();
                while (lr.hasLine()) {
                    byte[] line = lr.getLine();
                    i++;
                    j++;
                    long time2 = System.currentTimeMillis();
                    if (time2 - time > 1000) {
                        System.out.println("lines per second: " + j + " (" + i + ")");
                        j = 0;
                        time = time2;
                    }
                    Node<byte[]> child = new Node<byte[]>(null, line);
                    Node<byte[]> parent = findParentCached(child, r);
                    parent.addNode(child);
                }
                DefaultMutableTreeNode dmtn = r.toTreeNode();
                root.removeAllChildren();
                for (DefaultMutableTreeNode child : Frame.<DefaultMutableTreeNode>iter(dmtn.children())) {
                    root.add(child);
                }
            } catch (IOException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            }
            jTree1.repaint();
        }
    }//GEN-LAST:event_miLoadActionPerformed

    private static void aggregateLines(DefaultMutableTreeNode root, List<byte[]> lines) {
        Selection<byte[], EnumYNUM> obj = (Selection<byte[], EnumYNUM>)root.getUserObject();
        if (obj.state == EnumYNUM.Y) {
            lines.add(obj.val);
        }
        for (DefaultMutableTreeNode child : Frame.<DefaultMutableTreeNode>iter(root.children())) {
            aggregateLines(child, lines);
        }
    }
    
    private void miSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miSaveActionPerformed
        if (chooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            BufferedOutputStream bos = null;
            try {
                File f = chooser.getSelectedFile();
                ArrayList<byte[]> lines = new ArrayList<>();
                aggregateLines(root, lines);
                bos = new BufferedOutputStream(new FileOutputStream(f));
                boolean first = true;
                for (byte[] line : lines) {
                    if (!first) {
                        bos.write(0x0A);
                    }
                    bos.write(line);
                    first = false;
                }
                bos.flush();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    bos.close();
                } catch (IOException ex) {
                    Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }//GEN-LAST:event_miSaveActionPerformed

    private void miLoadStateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miLoadStateActionPerformed
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                File f = chooser.getSelectedFile();
                //List<String> lines = Files.readAllLines(f.toPath(), Charset.forName("windows-1252"));
                LineReader lr = new LineReader(f);
                Node<byte[]> r = new Node<>(null, new byte[]{});
                int i = 0;
                int j = 0;
                long time = System.currentTimeMillis();
                HashMap<Node<byte[]>, EnumYNUM> statuses = new HashMap<>();
                while (lr.hasLine()) {
                    byte[] line = lr.getLine();
                    EnumYNUM status = EnumYNUM.U;
                    if (line.length > 0) {
                        status = EnumYNUM.values()[line[0]-'0']; // Bit of a hack
                        line = Arrays.copyOfRange(line, 1, line.length);
                    }
                    i++;
                    j++;
                    long time2 = System.currentTimeMillis();
                    if (time2 - time > 1000) {
                        System.out.println("lines per second: " + j + " (" + i + ")");
                        j = 0;
                        time = time2;
                    }
                    Node<byte[]> child = new Node<byte[]>(null, line);
                    statuses.put(child, status);
                    Node<byte[]> parent = findParentCached(child, r);
                    parent.addNode(child);
                }
                DefaultMutableTreeNode dmtn = r.toTreeNode(statuses);
                root.removeAllChildren();
                for (DefaultMutableTreeNode child : Frame.<DefaultMutableTreeNode>iter(dmtn.children())) {
                    root.add(child);
                }
            } catch (IOException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            }
            jTree1.repaint();
        }
    }//GEN-LAST:event_miLoadStateActionPerformed

    private static void aggregateLinesState(DefaultMutableTreeNode root, BiConsumer<byte[], EnumYNUM> callback) {
        Selection<byte[], EnumYNUM> obj = (Selection<byte[], EnumYNUM>)root.getUserObject();
        callback.accept(obj.val, obj.state);
        for (DefaultMutableTreeNode child : Frame.<DefaultMutableTreeNode>iter(root.children())) {
            aggregateLinesState(child, callback);
        }
    }

    private void miSaveStateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_miSaveStateActionPerformed
        if (chooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            BufferedOutputStream bos = null;
            try {
                File f = chooser.getSelectedFile();
                bos = new BufferedOutputStream(new FileOutputStream(f));
                final BufferedOutputStream bos0 = bos;
                boolean[] first = {true};
                BiConsumer<byte[], EnumYNUM> callback = (line, state) -> {
                    try {
                        if (!first[0]) {
                            bos0.write(0x0A);
                        }
                        bos0.write('0'+state.ordinal());
                        bos0.write(line);
                        first[0] = false;
                    } catch (Throwable t) {
                        throw new RuntimeException(t);
                    }
                };
                for (DefaultMutableTreeNode child : Frame.<DefaultMutableTreeNode>iter(root.children())) {
                    aggregateLinesState(child, callback);
                }
                bos.flush();
            } catch (FileNotFoundException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    bos.close();
                } catch (IOException ex) {
                    Logger.getLogger(Frame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }//GEN-LAST:event_miSaveStateActionPerformed

    //TODO Export
    public static <E extends Enum> E cycleEnum(E val) {
        //val.
        return val;
    }
    
    private void treeItemAction(boolean reverse) {
        DefaultMutableTreeNode node = (DefaultMutableTreeNode) jTree1.getSelectionPath().getLastPathComponent();
        Selection<String, EnumYNUM> obj = (Selection<String, EnumYNUM>) node.getUserObject();
        //c.getDeclaredMethod("values").invoke(null)
        obj.state = EnumYNUM.values()[(obj.state.ordinal() + (reverse ? -1+EnumYNUM.values().length : 1)) % EnumYNUM.values().length];
        jTree1.repaint();
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Frame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new Frame().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTree jTree1;
    private javax.swing.JMenuItem miLoad;
    private javax.swing.JMenuItem miLoadState;
    private javax.swing.JMenuItem miSave;
    private javax.swing.JMenuItem miSaveState;
    // End of variables declaration//GEN-END:variables
}
